{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useContext, useState, useEffect } from \"react\";\nimport getGifs from '../services/getGifs.js';\nimport GifsContext from \"../context/GifsContext.js\";\nconst INITIAL_PAGE = 0;\nexport function useGifs() {\n  _s();\n\n  let {\n    keyword = ''\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // const [gifs, setGifs] = useState([]);\n  const {\n    gifs,\n    setGifs\n  } = useContext(GifsContext);\n  const [page, setPage] = useState(INITIAL_PAGE);\n  const [loading, setLoading] = useState(false);\n  const [loadingNextPage, setLoadingNextPage] = useState(false);\n  const keywordToUse = keyword ? keyword : localStorage.getItem('lastKeyword') || 'random'; //Recuperamos\n  //Este HOOK nos permite ejecutar una funcion cada vez que se renderice nuestro componente.\n\n  useEffect(function () {\n    setLoading(true);\n    getGifs({\n      keyword: keywordToUse\n    }).then(gifs => {\n      setGifs(gifs);\n      setLoading(false);\n      localStorage.setItem('lastKeyword', keyword); //Guardamos\n    });\n  }, [keyword, keywordToUse, setGifs]);\n  /*Los corchetes estan para que esta funcion solo se ejecute la \r\n  primera vez, si no los ponemos, la funcion entraria en un bucle infinito ya \r\n  que la funcion se ejecutaria cada vez que se renderice el componente, y \r\n  como estamos llamando al setGifs y actualizando el estado, esto se haria infinitamente.\r\n  En esos corchetes entonces, va ubicada la dependencia del useEffect, si esta \r\n  vacio solo se renderiza la primera vez, pero como nosotros queremosir actualizando\r\n  el keyword cuando se quiera, necesitamos que se renderice cada vez q se actualice,\r\n  y por eso le ponemos como dependencia esa prop, entonces cada vez q cambia ese\r\n  keyword, se actualiza y se renderiza todo de nuevo. */\n\n  useEffect(function () {\n    if (page = INITIAL_PAGE) return;\n    setLoadingNextPage(true);\n    getGifs({\n      keyword: keywordToUse,\n      page\n    }).then(nextGifs => {\n      /* Le pasamos al actualizador de estados una funcion que devuelve como \r\n      parametro el estado anterior. */\n      setGifs(prevGifs => prevGifs.concat(nextGifs));\n      setLoadingNextPage(false);\n    });\n  }, [keywordToUse, page]);\n  return {\n    loading,\n    loadingNextPage,\n    gifs,\n    keyword,\n    setPage\n  };\n}\n\n_s(useGifs, \"tA2K827o1r9D2Ib1u4JMV/rXduI=\");","map":{"version":3,"sources":["H:/Proyectos/mas-proyectos-de-react/giffy/src/hooks/useGifs.js"],"names":["React","useContext","useState","useEffect","getGifs","GifsContext","INITIAL_PAGE","useGifs","keyword","gifs","setGifs","page","setPage","loading","setLoading","loadingNextPage","setLoadingNextPage","keywordToUse","localStorage","getItem","then","setItem","nextGifs","prevGifs","concat"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCC,SAAtC,QAAsD,OAAtD;AACA,OAAOC,OAAP,MAAoB,wBAApB;AACA,OAAOC,WAAP,MAAwB,2BAAxB;AAEA,MAAMC,YAAY,GAAG,CAArB;AAEA,OAAO,SAASC,OAAT,GAAsC;AAAA;;AAAA,MAArB;AAACC,IAAAA,OAAO,GAAG;AAAX,GAAqB,uEAAJ,EAAI;AAC3C;AACA,QAAM;AAACC,IAAAA,IAAD;AAAOC,IAAAA;AAAP,MAAkBT,UAAU,CAACI,WAAD,CAAlC;AACA,QAAM,CAACM,IAAD,EAAOC,OAAP,IAAkBV,QAAQ,CAACI,YAAD,CAAhC;AACA,QAAM,CAACO,OAAD,EAAUC,UAAV,IAAwBZ,QAAQ,CAAC,KAAD,CAAtC;AACA,QAAM,CAACa,eAAD,EAAkBC,kBAAlB,IAAwCd,QAAQ,CAAC,KAAD,CAAtD;AAEA,QAAMe,YAAY,GAAGT,OAAO,GAAGA,OAAH,GACxBU,YAAY,CAACC,OAAb,CAAqB,aAArB,KAAuC,QAD3C,CAP2C,CAQS;AAEpD;;AACAhB,EAAAA,SAAS,CAAC,YAAW;AACnBW,IAAAA,UAAU,CAAC,IAAD,CAAV;AAEAV,IAAAA,OAAO,CAAC;AAAEI,MAAAA,OAAO,EAAES;AAAX,KAAD,CAAP,CACGG,IADH,CACQX,IAAI,IAAI;AACZC,MAAAA,OAAO,CAACD,IAAD,CAAP;AACAK,MAAAA,UAAU,CAAC,KAAD,CAAV;AACAI,MAAAA,YAAY,CAACG,OAAb,CAAqB,aAArB,EAAoCb,OAApC,EAHY,CAGkC;AAChD,KALF;AAMC,GATM,EASJ,CAACA,OAAD,EAAUS,YAAV,EAAwBP,OAAxB,CATI,CAAT;AASwC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEEP,EAAAA,SAAS,CAAC,YAAW;AACnB,QAAGQ,IAAI,GAAGL,YAAV,EAAwB;AAExBU,IAAAA,kBAAkB,CAAC,IAAD,CAAlB;AAEAZ,IAAAA,OAAO,CAAC;AAAEI,MAAAA,OAAO,EAAES,YAAX;AAAyBN,MAAAA;AAAzB,KAAD,CAAP,CACGS,IADH,CACQE,QAAQ,IAAI;AAEhB;AACR;AACQZ,MAAAA,OAAO,CAACa,QAAQ,IAAIA,QAAQ,CAACC,MAAT,CAAgBF,QAAhB,CAAb,CAAP;AACAN,MAAAA,kBAAkB,CAAC,KAAD,CAAlB;AACD,KAPH;AAQD,GAbQ,EAaN,CAACC,YAAD,EAAeN,IAAf,CAbM,CAAT;AAeA,SAAO;AAACE,IAAAA,OAAD;AAAUE,IAAAA,eAAV;AAA2BN,IAAAA,IAA3B;AAAiCD,IAAAA,OAAjC;AAA0CI,IAAAA;AAA1C,GAAP;AACD;;GA9CeL,O","sourcesContent":["import React, { useContext, useState, useEffect} from \"react\";\r\nimport getGifs from '../services/getGifs.js';\r\nimport GifsContext from \"../context/GifsContext.js\";\r\n\r\nconst INITIAL_PAGE = 0\r\n\r\nexport function useGifs({keyword = ''} = {} ){\r\n  // const [gifs, setGifs] = useState([]);\r\n  const {gifs, setGifs} = useContext(GifsContext);\r\n  const [page, setPage] = useState(INITIAL_PAGE);\r\n  const [loading, setLoading] = useState(false);\r\n  const [loadingNextPage, setLoadingNextPage] = useState(false);\r\n\r\n  const keywordToUse = keyword ? keyword \r\n    : localStorage.getItem('lastKeyword') || 'random' //Recuperamos\r\n\r\n  //Este HOOK nos permite ejecutar una funcion cada vez que se renderice nuestro componente.\r\n  useEffect(function() {\r\n    setLoading(true);\r\n\r\n    getGifs({ keyword: keywordToUse })\r\n      .then(gifs => {\r\n        setGifs(gifs);\r\n        setLoading(false);\r\n        localStorage.setItem('lastKeyword', keyword); //Guardamos\r\n     });\r\n    }, [keyword, keywordToUse, setGifs])  /*Los corchetes estan para que esta funcion solo se ejecute la \r\n      primera vez, si no los ponemos, la funcion entraria en un bucle infinito ya \r\n      que la funcion se ejecutaria cada vez que se renderice el componente, y \r\n      como estamos llamando al setGifs y actualizando el estado, esto se haria infinitamente.\r\n        En esos corchetes entonces, va ubicada la dependencia del useEffect, si esta \r\n      vacio solo se renderiza la primera vez, pero como nosotros queremosir actualizando\r\n      el keyword cuando se quiera, necesitamos que se renderice cada vez q se actualice,\r\n      y por eso le ponemos como dependencia esa prop, entonces cada vez q cambia ese\r\n      keyword, se actualiza y se renderiza todo de nuevo. */\r\n\r\n  useEffect(function() {\r\n    if(page = INITIAL_PAGE) return\r\n\r\n    setLoadingNextPage(true);\r\n\r\n    getGifs({ keyword: keywordToUse, page })\r\n      .then(nextGifs => {\r\n\r\n        /* Le pasamos al actualizador de estados una funcion que devuelve como \r\n        parametro el estado anterior. */\r\n        setGifs(prevGifs => prevGifs.concat(nextGifs))\r\n        setLoadingNextPage(false)\r\n      })\r\n  }, [keywordToUse, page])\r\n\r\n  return {loading, loadingNextPage, gifs, keyword, setPage}\r\n} "]},"metadata":{},"sourceType":"module"}