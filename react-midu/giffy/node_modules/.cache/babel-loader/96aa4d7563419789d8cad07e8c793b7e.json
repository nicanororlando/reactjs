{"ast":null,"code":"var _jsxFileName = \"H:\\\\Proyectos\\\\mas-proyectos-de-react\\\\giffy\\\\src\\\\componentes\\\\TrendingSearches\\\\TrendingSearches.js\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useState, useRef } from 'react';\nimport getTrendingTerms from 'services/getTrendingTerms';\nimport Category from '../Category/Category';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function TrendingSearches() {\n  _s();\n\n  const [trends, setTrends] = useState([]);\n  useEffect(function () {\n    getTrendingTerms().then(setTrends);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(Category, {\n    id: \"qcy\",\n    name: \"Tendencias\",\n    options: trends\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 13,\n    columnNumber: 10\n  }, this);\n} // // Para evitar que el componente se cargue cuando no lo estemos viendo.\n// export default function LazyTrending() {\n//   const [show, setShow] = useState(false);\n//   /* Parecido a un state, pero la diferencia en este caso cuando cambia el valor\n//   NO se vuelve a renderizar el componente, mientras q en useState si. */\n//   const elementRef = useRef() \n//   useEffect(function () {\n//     const onChange = (entries) => {\n//       const el = entries[0]\n//       if(el.isIntersecting){\n//         setShow(true)\n//         observer.disconnect()\n//       }\n//     }\n//     /* Esta API nos permite (entre otras cosas) detectar cuando un elemento esta\n//     en el ViePort. Recibe dos parametros: 1. El callback que se ejecutara cada vez que haya una \n//     actualizacion sobre lo que se esta observando. 2. Un objeto de opciones. */\n//     const observer = new IntersectionObserver(onChange, {\n//       rootMargin: '100px' //Margen para cargar un poco antes el elemento.\n//     })\n//     observer.observe(elementRef.current)  //.current para acceder al valor de la ref.\n//     return () => observer.disconnect()\n//   })\n//   return (\n//     <div ref={elementRef}>\n//       {show ? <TrendingSearches /> : null}\n//     </div>\n//   )\n// }\n\n_s(TrendingSearches, \"kLUnhehmoevJwfCWQUk2udGvkuc=\");\n\n_c = TrendingSearches;\n\nvar _c;\n\n$RefreshReg$(_c, \"TrendingSearches\");","map":{"version":3,"sources":["H:/Proyectos/mas-proyectos-de-react/giffy/src/componentes/TrendingSearches/TrendingSearches.js"],"names":["React","useEffect","useState","useRef","getTrendingTerms","Category","TrendingSearches","trends","setTrends","then"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAqCC,MAArC,QAAmD,OAAnD;AACA,OAAOC,gBAAP,MAA6B,2BAA7B;AACA,OAAOC,QAAP,MAAqB,sBAArB;;AAEA,eAAe,SAASC,gBAAT,GAA4B;AAAA;;AACzC,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBN,QAAQ,CAAC,EAAD,CAApC;AAEAD,EAAAA,SAAS,CAAC,YAAY;AACpBG,IAAAA,gBAAgB,GACbK,IADH,CACQD,SADR;AAED,GAHQ,EAGN,EAHM,CAAT;AAKA,sBAAO,QAAC,QAAD;AAAU,IAAA,EAAE,EAAE,KAAd;AAAoB,IAAA,IAAI,EAAC,YAAzB;AAAsC,IAAA,OAAO,EAAED;AAA/C;AAAA;AAAA;AAAA;AAAA,UAAP;AACD,C,CAED;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;GA5CwBD,gB;;KAAAA,gB","sourcesContent":["import React, { useEffect, useState, useRef } from 'react'\r\nimport getTrendingTerms from 'services/getTrendingTerms'\r\nimport Category from '../Category/Category'\r\n\r\nexport default function TrendingSearches() {\r\n  const [trends, setTrends] = useState([])\r\n  \r\n  useEffect(function () {\r\n    getTrendingTerms()\r\n      .then(setTrends)\r\n  }, [])\r\n\r\n  return <Category id= 'qcy' name='Tendencias' options={trends} />\r\n}\r\n\r\n// // Para evitar que el componente se cargue cuando no lo estemos viendo.\r\n// export default function LazyTrending() {\r\n//   const [show, setShow] = useState(false);\r\n\r\n//   /* Parecido a un state, pero la diferencia en este caso cuando cambia el valor\r\n//   NO se vuelve a renderizar el componente, mientras q en useState si. */\r\n//   const elementRef = useRef() \r\n\r\n//   useEffect(function () {\r\n\r\n//     const onChange = (entries) => {\r\n//       const el = entries[0]\r\n//       if(el.isIntersecting){\r\n//         setShow(true)\r\n//         observer.disconnect()\r\n//       }\r\n//     }\r\n\r\n//     /* Esta API nos permite (entre otras cosas) detectar cuando un elemento esta\r\n//     en el ViePort. Recibe dos parametros: 1. El callback que se ejecutara cada vez que haya una \r\n//     actualizacion sobre lo que se esta observando. 2. Un objeto de opciones. */\r\n//     const observer = new IntersectionObserver(onChange, {\r\n//       rootMargin: '100px' //Margen para cargar un poco antes el elemento.\r\n//     })\r\n//     observer.observe(elementRef.current)  //.current para acceder al valor de la ref.\r\n//     return () => observer.disconnect()\r\n//   })\r\n\r\n//   return (\r\n//     <div ref={elementRef}>\r\n//       {show ? <TrendingSearches /> : null}\r\n//     </div>\r\n//   )\r\n// }"]},"metadata":{},"sourceType":"module"}